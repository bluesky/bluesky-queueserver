import functools
import inspect
import jsonschema
import copy

_parameter_annotation_schema = {
    "type": "object",
    "properties": {
        "description": {"type": "string"},
        "parameters": {
            "type": "object",
            "additionalProperties": {
                "type": "object",
                "additionalProperties": False,
                "properties": {
                    "description": {"type": "string"},
                    "annotation": {"type": "string"},
                    "devices": {
                        "$ref": "#/definitions/custom_types",
                    },
                    "plans": {
                        "$ref": "#/definitions/custom_types",
                    },
                    "enums": {
                        "$ref": "#/definitions/custom_types",
                    },
                    "default": {"type": "string"},
                },
            },
        },
    },
    "additionalProperties": False,
    "definitions": {
        "custom_types": {
            "type": "object",
            "additionalProperties": {
                "type": "array",
                "items": [{"type": "string"}],
            },
        },
    },
}


def parameter_annotation_decorator(annotation):
    """
    The decorator allows to attach a custom description to a function or generator function.
    If a decorated function does not have a docstring, the decorator creates a function docstring
    based on information in the dictionary passed as a parameter, function signature and standard
    parameter annotations. The purpose of the decorator is to extend the standard Python annotation
    capabilities, so the information passed to the decorator should always take precedence over
    the information that is extracted from the docstring (typically textual descriptions of
    the function, its parameters and the return values) and function signature. All the fields in
    the dictionary passed to the decorator are optional, so only the parameters that are needed
    should be specified. In many cases the complete description of the function may be generated
    from the existing docstring and parameter hints and the use of the decorator may be avoided.

    The purpose of the custom parameter annotations is provide alternative type hints for some
    parameters. Those alternative hints may be necessary for validation of plan parameters outside
    the Run Engine environment. Standard Python types, such as ``float``, ``int`` or ``str``),
    may be unambiguously specified as parameter hints and used for plan validation and typechecking
    (e.g. with ``mypy``). Some plans may accept references to Ophyd devices or other bluesky plans
    as parameters. The correct type hints for those parameters would be ``ophid.device.Device``
    for the Ophyd device reference and ``typing.Callable`` for a reference to Bluesky plan. Those
    hints are suitable for type checking, but not helpful for validation of parameters performed
    outside Run Engine environment, where the devices and plans are represented by their names
    and validation of values include verification if a given device or plan can be used as
    the value for the given parameter. The custom description for such parameter specifies a set
    of lists (groups) of names of devices (plans) that are allowed to be used, tells if those names
    represent devices, plans or simply strings (``devices``, ``plans``, ``enums``) and allows
    to specify arbitrarily complex type hints using Python ``typing`` module (names of the name groups
    are used as custom types, see the example below).

    Another potential use of the decorator is to provide shorter textual descriptions (e.g. for tooltips)
    for the parameters in case if long description extracted from the function docstring is too detailed.

    The decorator does not change the function and does not overwrite an existing docstring.
    The decorator does not generate function descriptions, instead the parameter dictionary
    passed to the decorator is saved as ``_custom_parameter_annotation_`` attribute of the function
    and may be used by later for generation of plan descriptions. The additional field
    ``_custom_parameter_annotation_["docstring_autogenerated"] = True`` is added to the dictionary
    if the function docstring was generated by the decorator (autogenerated docstring should not be
    used for analysis, instead all data should be extracted from the function signature and the parameter
    dictionary).

    The decorator verifies if the parameter dictionary matches JSON schema and if names of all
    the parameter names exist in the function signature. The exception is raised if there is
    a mismatch.

    The following is an example of custom annotation (Python dictionary) with inline comments:

    .. code-block:: python

        {
            # Optional function description. The function and parameter descriptions are formatted
            #   to fit the width of 80 characters.
            "description": "Custom annotation with plans and devices.",

            # 'parameters' block is optional. Empty 'parameters' block will also be accepted.
            # The keys in the parameter block are names of the function arguments. The docstring
            # entries will be generated based on the function argument type hints
            # if no custom annotation for the parameter is provided. The parameters listed
            # in this block must exist in function signature, otherwise an exception will be raised.
            # Function signature for this example is:
            #     func(plan_or_plans, some_name, dwell_time, str_or_int_or_float, devices)
            # The parameters may have default values, which must be specified as part of the function
            # definition. The default values are included in the generated docstring.
            "parameters": {
                # Parameter that accepts a plan (unusual, but supported by the decorator).
                "plan_or_plans": {
                    # The parameter text descriptions are optional.
                    "description": "Parameter that accepts a plan or a list of plans.",
                    "annotation": "typing.Union[Plan1, typing.List[Plan2]]",
                    "plans": {
                        # Here we have two groups of plans. Names of the plans are used as types in
                        #   'annotation'. The example of annotation above allows to pass one plan
                        #   from the group 'Plan1' or a list of plans from 'Plan2'.
                        "Plan1": ("count", "scan", "gridscan"),
                        "Plan2": ("some", "more", "plan", "names"),
                    },
                },
                "some_name": {
                    # This parameter will probably have type hint 'some_name: str`.
                    "description": "String selected from a list of strings (similar to enum)",
                    "annotation": "Names",
                    # Note, that "devices", "plans" and "names" are treated identically during type
                    #   checking, since they represent lists of strings. One parameter may have
                    #   name groups from "devices", "plans" and "enums" combined in complex expression
                    #   using 'typing' module.
                    "enums": {
                        "Names": ("name1", "name2", "name3"),
                    },
                }
                "dwell_time": {
                    "description": "Dwell time.",
                    # The simple type 'float' should probably be specified as a parameter hint, but it can
                    #   also be specified here. Putting it in both places will also work.
                    "annotation": "float",
                }
                "str_or_int_or_float": {
                    "description": "Some values that may be of 'str', 'int' or 'float' type.",
                    # The following expression can also be put as the parameter hint.
                    "annotation": "typing.Union[str, int, float]",
                }
                "devices": {
                    "description": "Parameter that accepts the list of devices.",
                    "annotation": "typing.List[Device]",
                    # Here we provide the list of devices. 'devices' and 'plans' are treated
                    #   similarly, but it may be useful to distinguish lists of plans and devices
                    #   on the stage of plan parameter validation.
                    "devices": {
                        "Device": ("det1", "det2", "det3"),
                    },
                },
            },

            # 'returns' block is optional. Returns block is used both for regular functions and
            #   generator functions. The created docstring will have 'Yields' or 'Returns' block
            #   depending on whether the function is a generator. Also if the function is
            #   a generator, the yield type will be automatically extracted from the expressions
            #     typing.Iterator[<type>]
            #     typing.Iterable[<type>]
            #     typing.Generator[<type>, sometype, sometype]
            #   and placed in docstring as Yield type.
            "returns": {
                "description": "Sequence of number",
                "annotation": "str"
            },
        }

    Raises
    ------
    jsonschema.ValidationError
        The parameter dictionary does not match the schema.
    ValueError
        The dictionary contains parameters that are not function arguments (not in the function signature).
    """

    def function_wrap(func):
        if inspect.isgeneratorfunction(func):

            @functools.wraps(func)
            def wrapper(*args, **kwargs):
                return (yield from func(*args, **kwargs))

        else:

            @functools.wraps(func)
            def wrapper(*args, **kwargs):
                return func(*args, **kwargs)

        # Always create the copy (annotation dictionary may be reused)
        nonlocal annotation
        annotation = copy.deepcopy(annotation)

        jsonschema.validate(
            instance=annotation, schema=_parameter_annotation_schema, types={"array": (list, tuple)}
        )

        sig = inspect.signature(func)
        parameters = sig.parameters

        param_unknown = []
        if "parameters" in annotation:
            for p in annotation["parameters"]:
                if p not in parameters:
                    param_unknown.append(p)
        if param_unknown:
            msg = (
                f"Custom annotation parameters {param_unknown} are not "
                f"in the signature of function '{func.__name__}'."
            )
            raise ValueError(msg)

        setattr(wrapper, "_custom_parameter_annotation_", annotation)

        return wrapper

    return function_wrap
